#pragma once
#include <yuzaos.h>
#include <winapi.h>
#include  <inttypes.h>

// Type info stuff
#ifdef __cplusplus
struct __type_info_node
{
	_SLIST_HEADER _Header;
};

void __cdecl __std_type_info_destroy_list(__type_info_node* _RootNode);
#endif

#if defined _M_CEE_MIXED && !defined _VCRT_BUILD
// Provide a fake definition of __type_info_node to suppress linker warning
// LNK4248: unresolved typeref token for '__type_info_node'; image may not run.
struct __type_info_node { };
#else
struct __type_info_node;
#endif

#ifdef _M_CEE_PURE
extern System::IntPtr __type_info_root_node;
#else
extern __type_info_node __type_info_root_node;
#endif

#ifndef _VCRTIMP
#if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
#define _VCRTIMP _CRTIMP
#elif defined _VCRT_BUILD && defined CRTDLL && !defined _VCRT_SAT_1
#define _VCRTIMP __declspec(dllexport)
#else
#define _VCRTIMP
#endif
#endif

#define _In_
#define _Inout_

_CRT_BEGIN_C_HEADER

struct __std_type_info_data
{
	const char* _UndecoratedName;
	const char   _DecoratedName[1];
	__std_type_info_data() = delete;
	__std_type_info_data(const __std_type_info_data&) = delete;
	__std_type_info_data(__std_type_info_data&&) = delete;

	__std_type_info_data& operator=(const __std_type_info_data&) = delete;
	__std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

_VCRTIMP int __cdecl __std_type_info_compare(
	_In_ const __std_type_info_data* _Lhs,
	_In_ const __std_type_info_data* _Rhs
);

_VCRTIMP size_t __cdecl __std_type_info_hash(
	_In_ const __std_type_info_data* _Data
);

/*_VCRTIMP const char* __cdecl __std_type_info_name(
	_Inout_ __std_type_info_data* _Data,
	_Inout_ __type_info_node* _RootNode
);*/

extern "C" char const* __cdecl __std_type_info_name(
	__std_type_info_data* const data,
	__type_info_node* const root_node
);

_CRT_END_C_HEADER

#pragma warning(push)
#pragma warning(disable: 4577) // 'noexcept' used with no exception handling mode specified
class type_info
{
public:

	type_info(const type_info&) = delete;
	type_info& operator=(const type_info&) = delete;

	size_t hash_code() const noexcept
	{
		return __std_type_info_hash(&_Data);
	}

	bool operator==(const type_info& _Other) const noexcept
	{
		return __std_type_info_compare(&_Data, &_Other._Data) == 0;
	}

#if !_HAS_CXX20
	bool operator!=(const type_info& _Other) const noexcept
	{
		return __std_type_info_compare(&_Data, &_Other._Data) != 0;
	}
#endif // !_HAS_CXX20

	bool before(const type_info& _Other) const noexcept
	{
		return __std_type_info_compare(&_Data, &_Other._Data) < 0;
	}

	const char* name() const noexcept
	{
#ifdef _M_CEE_PURE
		return __std_type_info_name(&_Data, static_cast<__type_info_node*>(__type_info_root_node.ToPointer()));
#else
		return __std_type_info_name(&_Data, &__type_info_root_node);
#endif
	}

	const char* raw_name() const noexcept
	{
		return _Data._DecoratedName;
	}

	virtual ~type_info() noexcept;

private:

	mutable __std_type_info_data _Data;
};
#pragma warning(pop)

namespace std {
	using ::type_info;
}
